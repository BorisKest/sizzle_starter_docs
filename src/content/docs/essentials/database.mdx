---
title: Database
description: Database and Drift
---

Our projects mainly focus on interacting with the backend through message exchange. 
At times, we need to store data for caching or similar reasons. While there's a wide 
range of options available, various factors must be considered carefully. After evaluating 
numerous libraries, we've selected [SQLite](https://www.sqlite.org/index.html) as 
our preferred choice.

## SQLite

SQLite is a compact, relational database management system designed for efficient 
disk-based operations. It's widely utilized in a variety of settings, including 
desktop and mobile applications, IoT devices, and web environments. With its deployment 
in millions of production applications globally, SQLite's robustness is further reinforced 
by an extensive suite of over one billion test cases, ensuring a high level of reliability 
and minimal error incidence.

More about SQLite can be found [here](https://www.sqlite.org/whentouse.html).

## Drift

Drift is a robust database library designed for Dart and Flutter applications. It empowers developers with
advanced features such as type-safe SQL queries, database verification, and seamless migrations. Drift
leverages a builder and command-line tooling that operates during compile-time, ensuring efficient and
error-resistant database interactions in Dart and Flutter projects.

### Defining SQL tables

To define a table, we need to create a class that extends Table. The class name will be the name of the
table. The fields of the class will be the columns of the table. The type of the field will be the type
of the column.

```dart
class Spendings extends Table {
    IntColumn get id => integer().autoIncrement()();
    RealColumn get price => real().withDefault(const Constant(0.0))();
    TextColumn get title => text()();
    TextColumn get currency => text().nullable()();
    DateTimeColumn get date => dateTime()();
}
```

detailed description of defining tables can be found
[here](https://drift.simonbinder.eu/docs/getting-started/advanced_dart_tables/)

### Writing data

After we have created a table and data source for our expenses, we can write some data in it,

```dart
    await database.into(spendings).insert(
      SpendingsCompanion.insert(
        price: Value(3.9),
        title: 'Coffee',
        currency: Value('USD'),
        date: DateTime.now(),
      ),
    );
```

delete data,

```dart
    await (database.delete(spendings)
        ..where: (tbl) => tbl.id.equals(1)
        ..where: (tbl) => tbl.title.equals('Coffee'))
        .go();
```

or update data.

```dart
    await (database.update(spendings)
        ..where: (tbl) => tbl.id.equals(id))
        .write: SpendingsCompanion(
            price: Value(2.9),
            title: 'Coffee',
            currency: Value('USD'),
            date: DateTime.now(),
        );
    
```

More detailed information about data writing operations, you can find  
[here](https://drift.simonbinder.eu/docs/dart-api/writes/).

### Reading data

To read data, we need to create a query that will return the data we need.

For example, we can retrieve paginated data from the table with specific date and order it by price.

```dart
    final allSpendings = await (database.select(spendings)
            ..where((tbl) => tbl.date.equals(date))
            ..orderBy([(t) => OrderingTerm.desc(t.price)])
            ..limit(20, offset: offset)) // offset is optional and defaults to 0, used for pagination
        .get();
```

No one will stop us from combining everything together, but that's covered
[here](https://drift.simonbinder.eu/docs/dart-api/select/).

### Migrations

Predicting initial data requirements for a table can be complex, as data needs often evolve, 
requiring new fields or tables. Migration tools are crucial for adapting the database structure 
to these changing requirements, ensuring flexibility and robustness.


[Migration API](https://drift.simonbinder.eu/docs/migrations/)


#### Local package

The database schema is moved to a different package called database. There are a few reasons 
for this: the schema itself doesn't change frequently, so there is no need to spend time during 
the codegen. Moreover, it improves project organization as everything related to database is 
grouped in different package. This package also provides executors logic.

**Executor** is a component tasked with managing and executing database queries. To guarantee optimal 
performance and compatibility, Drift utilizes different executors tailored to each platform. These 
platform-specific executors are engineered to align with the unique nuances and requirements of their 
respective platforms, ensuring efficient and seamless database interactions across a range of devices.