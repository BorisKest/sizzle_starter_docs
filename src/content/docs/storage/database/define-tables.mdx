---
title: "Define Tables"
description: "Learn how to define tables with Dart and SQL code."
---

import { Tabs, TabItem } from "@astrojs/starlight/components";

There are two ways to define a table in Drift - using Dart code or using
SQL code. Dart code is easier, but SQL code is more powerful and decouples
the table definition from the Dart code. Generally, SQL code is preferred.

See how to define tables using Dart code and SQL code below.

```dart
/// Todos table definition
final class TodosTable extends Table {
  /// The identifier for this todo.
  IntColumn get id => integer().autoIncrement()();

  /// The title of this todo.
  TextColumn get title => text().withLength(min: 6, max: 32)();

  /// The content of this todo.
  TextColumn get content => text().named('body')();

  /// Category of this todo.
  IntColumn get category => integer().nullable()();

  /// Created at timestamp.
  DateTimeColumn get createdAt => dateTime().clientDefault(() => DateTime.now())();

  /// Updated at timestamp.
  DateTimeColumn get updatedAt => dateTime().nullable()();
}
```

SQL code is defined in `.drift` files. The following example defines the
same table as above:

```sql
CREATE TABLE todos(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  category INTEGER,
  created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
  updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')) CHECK(updated_at >= created_at),
);
```

To make code generation work, you must point to the `.drift` file or
dart `Table` in the `@DriftDatabase` annotation:

```dart
@DriftDatabase(tables: [TodosTable]); // or
@DriftDatabase(include: {'todos.drift'});
```

## Column types

Drift supports the following column types:

- `int` - INTEGER
- `double` - REAL
- `bool` - INTEGER (0 or 1)
- `String` - TEXT
- `DateTime` - INTEGER (Unix timestamp) or TEXT
- `Uint8List` - BLOB
- `Enum` - INTEGER

## Keys

Keys are used to enforce uniqueness of rows and to reference rows from
other tables. Drift supports the following keys:

### Primary Key

Primary key is a column or a set of columns that uniquely identify a row
in a table. It is used to enforce uniqueness of rows and to reference
rows from other tables.

Drift automatically defines a primary key if you use
`autoIncrement()`:

```dart
IntColumn get id => integer().autoIncrement()();
```

If you want to define a primary key manually:

```dart
// Override primaryKey in table
@override
Set<Column<Object>> get primaryKey => {id, ... };
```

SQL code:

```sql
CREATE TABLE todos(
  id INTEGER AUTOINCREMENT,
  PRIMARY KEY(id, ...)
);
```

### Foreign Key

Foreign key is a column (or collection of columns) in one table that uniquely
identifies a row of another table. The role of a foreign key is to
enforce referential integrity within the database.

To reference a column from another table, use `references`:

```dart
IntColumn get categoryId => integer().nullable().references(categories, #id)();
```

SQL code:

```sql
CREATE TABLE todos(
  ...
  category INTEGER REFERENCES categories(id)
);
```

## Modifiers

Modifiers are used to define constraints on columns. Drift supports the
following modifiers:

### Default values

If no value is specified for a column when inserting a row, the database
automatically uses the column's default value.

To define a default value, use `withDefault`:

```dart
TextColumn get title => text().withDefault(const Constant('Untitled'))();
```

SQL code:

```sql
CREATE TABLE todos(
  ...
  title TEXT NOT NULL DEFAULT 'Untitled'
);
```

### Nullable columns

Some columns may not have a value. To define a nullable column, use
`nullable`:

```dart
IntColumn get category => integer().nullable()();
```

SQL code:

```sql
CREATE TABLE todos(
  ...
  category INTEGER
);
```

### Auto-incrementing columns

Auto-incrementing columns are used to automatically generate a unique
value for each new row. To define an auto-incrementing column, use
`autoIncrement`:

```dart
IntColumn get id => integer().autoIncrement()();
```

SQL code:

```sql
CREATE TABLE todos(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  ...
);
```

### Length constraints

To define a length constraint, use `withLength`:

```dart
TextColumn get title => text().withLength(min: 6, max: 32)();
```

SQL code:

```sql
CREATE TABLE todos(
  ...
  title TEXT NOT NULL CHECK(LENGTH(title) >= 6 AND LENGTH(title) <= 32)
);
```

### Check constraints

Check constraints are used to enforce domain integrity. For example, to
ensure that the price of a product is greater than 0 you may use:

```dart
IntColumn get price => integer().check(price.isBiggerThan(const Constant(0)))()
```

SQL code:

```sql
CREATE TABLE todos(
  ...
  price INTEGER NOT NULL CHECK(price > 0)
);
```

## Indexes

Indexes improve read performance by making it faster to look up values in
a column. But they slow down writes, so they should only be used when
necessary.

To create an index, you must use SQL code:

```sql
CREATE INDEX index_name ON table_name(column_name, ...);
```

If you want to maintain tables in Dart code, you need to import
dart code into the `.drift` file:

```sql
import 'tables.dart';

CREATE INDEX index_name ON table_name(column_name, ...);
```

## Triggers

Triggers are used to execute custom code when a certain event occurs in
the database. To create a trigger, you must use SQL code.

Let's create a trigger that will automatically update the `updated_at`
column when a row is updated:

```sql
CREATE TRIGGER update_timestamp
AFTER UPDATE ON todos
FOR EACH ROW
BEGIN
  UPDATE todos SET updated_at = strftime('%s', 'now') WHERE id = OLD.id;
END;
```

## Dart vs SQL

Dart code is known for its simplicity and beginner-friendly nature.
However, SQL, with its numerous benefits, stands as a preferable choice in many
scenarios. It's recommended to invest time in understanding SQL, given its
superior capabilities. SQL's strength lies in its ability to separate table
definitions from Dart code, granting access to the full spectrum of SQL's features.

In situations demanding the creation of intricate tables or the formulation of
extensive queries, SQL's performance surpasses that of Dart code. Moreover,
SQL's syntax is not only more legible but also simpler to manage and maintain
over time.
