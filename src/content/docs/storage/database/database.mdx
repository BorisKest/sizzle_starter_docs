---
title: Database
description: Database and Drift
---

Our projects mainly focus on interacting with the backend through message exchange.
At times, we need to store data for caching or similar reasons. While there's a wide
range of options available, various factors must be considered carefully. After evaluating
numerous libraries, we've selected [SQLite](https://www.sqlite.org/index.html) as
our preferred choice.

## SQLite

SQLite is a compact, efficient relational database system widely used in desktop,
mobile, and IoT sectors. Its robustness is proven in millions of applications
worldwide, supported by a rigorous testing process with over a billion cases,
ensuring high reliability and low error rates.

More about SQLite can be found [here](https://www.sqlite.org/whentouse.html).

## Drift

Drift is a robust database library designed to interact with SQLite using Dart APIs.
It empowers provides advanced features such as type-safe SQL queries, transactions,
and smooth migrations.

### Defining SQL tables

To define a table in SQLite, create a class that inherits from `Table`.
The class name becomes the table name, while its fields represent the table's columns.
The data type of each field determines the corresponding column type.

```dart
class Spendings extends Table {
    IntColumn get id => integer().autoIncrement()();
    RealColumn get price => real().withDefault(const Constant(0.0))();
    TextColumn get title => text()();
    TextColumn get currency => text().nullable()();
    DateTimeColumn get date => dateTime()();
}
```

What is more, it is possible to generate code from .SQL files.
More about it can be found [here](https://drift.simonbinder.eu/docs/getting-started/advanced_dart_tables/)

### Querying

#### Writing Data

To insert new records into the `spendings` table:

```dart
await database.into(spendings).insert(
  SpendingsCompanion.insert(
    price: Value(3.9),
    title: 'Coffee',
    currency: Value('USD'),
    date: DateTime.now(),
  ),
);
```

#### Deleting Data

To remove records from the `spendings` table:

```dart
await (database.delete(spendings)
    ..where((tbl) => tbl.id.equals(1))
    ..where((tbl) => tbl.title.equals('Coffee')))
    .go();
```

#### Updating Data

To update existing records in the `spendings` table:

```dart
await (database.update(spendings)
    ..where((tbl) => tbl.id.equals(id)))
    .write(
      SpendingsCompanion(
        price: Value(2.9),
        title: 'Coffee',
        currency: Value('USD'),
        date: DateTime.now(),
      ),
    );
```

#### Reading data

Finally, to read data from the `spendings` table:

```dart
    final allSpendings = await (database.select(spendings)
            // Filtering
            ..where((tbl) => tbl.date.equals(date))
            // Ordering
            ..orderBy([(t) => OrderingTerm.desc(t.price)])
            // Pagination
            ..limit(20, offset: offset))
        .get();
```

#### Further Information

For more detailed information about writing queries

### Migrations

Predicting initial data requirements for a table is challenging due to evolving
needs, often requiring new fields or tables. Migration tools are essential in
adapting the database structure to these changes, ensuring flexibility and robustness.

Drift's migration strategy lets you define database version migrations within
the database class. See the below example for details:

```dart
class Todos extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get title => text().withLength(min: 6, max: 10)();
  TextColumn get content => text().named('body')();
  IntColumn get category => integer().nullable()();
  // new, added column in v2
  DateTimeColumn get dueDate => dateTime().nullable()();
  // new, added column in v3
  IntColumn get priority => integer().nullable()();
}

@override
int get schemaVersion => 3; // bump because the tables have changed.

@override
MigrationStrategy get migration {
  return MigrationStrategy(
    onCreate: (Migrator m) async {
      await m.createAll();
    },
    onUpgrade: (Migrator m, int from, int to) async {
      if (from < 2) {
        // we added the dueDate property in the change from version 1 to
        // version 2
        await m.addColumn(todos, todos.dueDate);
      }
      if (from < 3) {
        // we added the priority property in the change from version 1 or 2
        // to version 3
        await m.addColumn(todos, todos.priority);
      }
    },
  );
}
```

Visit [docs](https://drift.simonbinder.eu/docs/getting-started/migrations/)
for more information.

## Local package

The database schema is now in a separate 'database' package, primarily because
it seldom changes and to streamline project organization by centralizing
database-related elements, including executor logic.

### Executor

An Executor manages and executes database queries. Drift uses distinct executors
for each platform, optimized for performance and compatibility,
ensuring smooth database operations on various devices.

Database package provides such executors for Native and Web platforms.

See the below example for details:

```dart
// Native
FutureOr<QueryExecutor> createExecutor(String name) {
  final db = LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(path.join(dbFolder.path, 'db.sqlite'));
    return NativeDatabase(file);
  });

  return db;
}

// Web
FutureOr<QueryExecutor> createExecutor(String name) async {
  final result = await WasmDatabase.open(
    databaseName: name,
    sqlite3Uri: Uri.parse('/sqlite3.wasm'),
    driftWorkerUri: Uri.parse('/drift_worker.dart.js'),
  );
  return result.resolvedExecutor;
}
```
